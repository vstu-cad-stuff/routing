from data_loader import Clusters
from greedy_algorithm import greedyInit


# function: convert list to human readable format
# input:
#   lst -- array list
# output:
#   python list
def toHR(lst):
    return list(map(lambda x: x+1, lst))


# funciont: separation of the array with count parts
# input:
#   array -- input array
#   count -- parts count
# output:
#   python list
def toChunk(array, count):
    chunk_len = len(array) // count
    rest_count = len(array) % count
    chunks = []
    for i in range(count):
        chunk = array[:chunk_len]
        array = array[chunk_len:]
        if rest_count and array:
            chunk.append(array.pop(0))
            rest_count -= 1
        chunks.append(chunk)
    return chunks


# function: routes rating function
# input:
#   data  -- cluster data class (correspondence matrix, coordinates)
#   routes -- route network
# output:
#   (distance, )
def routeRating(data, routes):
    total_distance = 0
    for route in routes:
        total_distance += data.getRouteLength(route)
    pass


# function: swap
# input:
#   arr -- python list
#   i   -- first index
#   j   -- second index
# output:
#   None
def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]


# function: sorting route by distance
# input:
#   data  -- cluster data class (correspondence matrix, coordinates)
#   route -- list of cluster_id
# output:
#   route -- sorted list of cluster_id
def sortByDistance(data, route):
    for index in range(len(route)-3):
        p1 = data.getDistance(route[index+0], route[index+1])
        p2 = data.getDistance(route[index+0], route[index+2])
        p3 = data.getDistance(route[index+1], route[index+2])
        if p1 + p2 > p2 + p3:
            swap(route, index+1, index+2)


# function: mutation
# input:
#   data  -- cluster data class (correspondence matrix, coordinates)
#   route -- route list before mutation
#   parts -- number of parts (mutation parameter)
# output:
#   route -- route list after mutation
def mutation(data, route, parts=2):
    split_route = toChunk(route, parts)
    new_route = []
    for item in split_route:
        sortByDistance(data, item)
        new_route += item
    return new_route


# function: crossover
# input:
#   data   -- cluster data class (correspondence matrix, coordinates)
#   route  -- route list before crossover
# output:
#   route  -- route list after crossover
def crossover(data, route):
    from math import sqrt
    people = [data.matrix[i][i] for i in route]
    # insert code
    return route


# function: generation of the route network, based on the greedy algorithm
# input:
#   data  -- cluster data class (correspondence matrix, coordinates)
#   route -- route generated by greedy algorithm
# output:
#   python list of list -- [[route1], [route2], ...]
def buildRoutes(data, route):
    route_count = 5
    routes = toChunk(route, route_count)
    for index in range(len(routes)):
        print('[{}] before = {}'.format(index, toHR(routes[index])))
        result = mutation(data, routes[index])
        print('[{}]  after = {}'.format(index, toHR(result)))
    # insert code

if __name__ == '__main__':
    data = Clusters()
    data.generateMatrix('./data/100_p.js', './data/ways.js')
    data.loadClusters('./data/100_c.js')
    init_route = greedyInit(data.matrix)
    result = buildRoutes(data, init_route)
