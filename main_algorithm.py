from data_loader import Clusters
from greedy_algorithm import greedyInit
import auxiliary as ax
import numpy as np


# function: mutation
# input:
#   data  -- cluster data class (correspondence matrix, coordinates)
#   route -- route list before mutation
#   parts -- number of parts (mutation parameter)
# output:
#   route -- route list after mutation
def mutation(data, route, parts=2):
    split_route = ax.toChunk(route, parts)
    new_route = []
    for item in split_route:
        if np.random.random() >= 0.5:
            ax.sortByMetric(data.getDistance, item)
        else:
            ax.sortByMetric(data.getPeople, item)
        new_route += item
    return new_route


# function: crossover
# input:
#   data   -- cluster data class (correspondence matrix, coordinates)
#   route  -- route list before crossover
# output:
#   route  -- route list after crossover
def crossover(data, route):
    from copy import deepcopy
    old_route = deepcopy(route)
    peoples = list(map(lambda x: int(data.getPeople(x, x)), old_route))
    new_route = []
    ax.funcRemoveAppend(max, peoples, old_route, new_route)
    i = 0
    while len(old_route) > 0:
        distances = list(map(lambda x: data.getDistance(new_route[i], x), old_route))
        ax.funcRemoveAppend(min, distances, old_route, new_route)
        i += 1
    return new_route


# function: generation of the route network, based on the greedy algorithm
# input:
#   data  -- cluster data class (correspondence matrix, coordinates)
#   route -- route generated by greedy algorithm
# output:
#   python list of list -- [[route1], [route2], ...]
def buildRoutes(data, route):
    route_count = 5
    iteration_count = 20
    routes = ax.toChunk(route, route_count)
    for iteration in range(iteration_count):
        rate_before = ax.routeRating(data, routes)
        print('iteration {} --> {}'.format(iteration, rate_before))
        new_routes = []
        for index in range(len(routes)):
            if np.random.random() >= 0.5:
                result = mutation(data, routes[index])
            else:
                result = crossover(data, routes[index])
            new_routes.append(result)
        rate_after = ax.routeRating(data, new_routes)
        if rate_after < rate_before:
            routes = new_routes
    return routes

if __name__ == '__main__':
    data = Clusters()
    data.generateMatrix('./data/100_p.js', './data/ways.js')
    data.loadClusters('./data/100_c.js')
    init_route = greedyInit(data.matrix)
    result = buildRoutes(data, init_route)
