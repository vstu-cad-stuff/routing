#!/bin/env python
# -*- coding: utf-8 -*-

W = [170, 1170, 910, 230, 780, 700, 70, 300, 420, 250]
G = [
    [  0, 403, 446, 244, 257, 343,   2, 455,  68, 355],
    [403,   0, 360, 299, 381, 162, 429, 259, 475, 483],
    [446, 360,   0, 490,  92, 159, 197, 281, 333, 200],
    [244, 299, 490,   0, 320, 496, 453, 283, 183, 100],
    [257, 381,  92, 320,   0, 251, 117, 359, 256, 312],
    [343, 162, 159, 496, 251,   0,  99, 170, 478,  55],
    [  2, 429, 197, 453, 117,  99,   0, 171, 487, 131],
    [455, 259, 281, 283, 359, 170, 171,   0, 367,  92],
    [ 68, 475, 333, 183, 256, 478, 487, 367,   0, 212],
    [355, 483, 200, 100, 312,  55, 131,  92, 212,   0]
]

# функция поиска максимума в списке (в правой части от главной диагонали)
def find_max(A):
    max_a = A[1][0]
    n, m = 1, 0
    for i in range(1, len(A)):
        for j in range(i+1, len(A)):
            if A[j][i] > max_a:
                max_a = A[j][i]
                n, m = i, j
    return n, m

# функция максимума между двумя вершинами
def max_in(n, m, A):
    if A[n] > A[m]:
        return n, m
    else:
        return m, n

# фунция поиска максимума в списке с нумерацией
def max_lst(A):
    max_a = A[0]
    n = 0
    for i in range(len(A)):
        if A[i] > max_a:
            max_a = A[i] 
            n = i
    return n

if __name__ == '__main__':
    # загружаем данные из файла
    f = open('./data/points.txt', 'r')
    s = f.read().splitlines()
    f.close()
    # преобразуем данные из файла к виду [[0, 1], ...]
    N = list(map(lambda x: [float(x.split(' ')[0]), float(x.split(' ')[1])], s))
    f = open('routing.js', 'w')
    # цикл по маршрутам
    for x in range(len(W)//2):
        # список для хранения вершин
        path = []
        # находим максимальное ребро в G и получаем номера вершин
        n, m = find_max(G)
        # находим максимальную вершину для старта
        s, r = max_in(n, m, W)
        print('[step0] start point \'{:.6f}, {:.6f}\' [{}]'.format(N[s][0], N[s][1], s))
        # закрываем путь назад
        G[m][n] = -1
        # добавляем номер вершины в список
        path.append(s)
        # цикл по вершинам
        for p in range(1, len(W)):
            # находим максимальное ребро в G и получаем номера вершин
            s, r = max_in(n, m, W)
            # если r есть в списке, то меняем местами вершины
            if r in path:
                s, r = r, s
            # делаем выборку по столбцу (куда можно пойти из этой вершины)
            lst = list(map(lambda x: x[r], G))
            # находим максимальный элемент в столбце (лучший вариант)
            n = max_lst(lst)
            print('[step{}]  next point \'{:.6f}, {:.6f}\' [{}]'.format(p, N[r][0], N[r][1], r))
            # закрываем путь назад
            G[r][n] = -1
            # добавляем номер вершины в список (если её нет в нём)
            if r in path:
                # иначе прекращаем строить этот маршрут
                break
            path.append(r)
        print('[{:05}] Result path = {}\n'.format(x + 1, path))
        f.write('path[{}] = [\n'.format(x))
        for p in path:
            f.write('\t[{:0.06f}, {:0.06f}],\n'.format(N[p][0], N[p][1]))
        f.write('];\n')
    f.close()